 \subsection{Setup}
    We implemented the cover tree in C++ and compiled it with g++-7.4.0. We executed all of our experiments on a Linux machine running on an AMD Opteron Processor 6174 with 2.2GHz and 256GB of RAM. In our experiments, we evaluate $A_{\text{CGS}}$ and $A_{\text{Cov}}$ with the following pairwise combinations of $\varepsilon \in \{0.1, 0.5, 1, 4\}$ and $k \in \{20, 50, 100, 200\}$. In total, we perform 10 different runs for each test instance and compute the arithmetic mean of the solution improvement and speedup on this instance. When further averaging over multiple instances, we use the geometric mean in order to give every instance a comparable influence on the final score. To measure the solution quality of an algorithm at any timepoint $i$ we query for the current set of centers $C_i$. We do not directly compute the objective function value $\phi(C_i)$, since this is an expensive operation and it is not usually needed in practice. After the termination of the two algorithms, we compute the objective function of the \textit{k}-center solution $\phi(C_i)$ in order to compare the solutions of the two competing algorithms $A_{\text{Cov}}$ and $A_{\text{CGS}}$. Hence, the running times of both algorithms include the time to perform the point insertions/deletions and the queries (obtaining the centers of the solution), but not computing the objective function.
